package com.fei.playground.algorithm.leetcode;

/**
 * - 01背包 416 分割等和子集
 * - 完全背包 279:完全平方数 322 零钱兑换 518 零钱兑换2 70:爬楼梯进阶版
 * - 多重背包
 * - 多维背包 474 一和零 879 盈利计划
 * - 背包求方案数字 494 目标和 879 盈利计划
 * - 背包求具体方案 1049 最后一块石头的重量ii
 */
public class M_DP_BagProblemGuide {

    /**
     * 01背包
     * 有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是 value[i] 。
     * 每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
     * - 暴力破解就用回溯，O(2^n)
     * ----------------------二位数组解法分割线----------------------
     * 1. 定义数组: dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。(横轴i代表物品，纵轴j背包重量)
     * 2. 方程式: 那么可以有两个方向推出来dp[i][j]:
     * 2.1 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是 dp[i - 1][j]
     * 2.2 由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时 候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] (物品i的价值)， 就是背包放物品i得到的最大价值
     * 2.3 所以公式: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
     * 3. 初始化dp[i][0]全都是0，因为容量是0；dp[0][j] 当j大于0号物品的重量时，dp[0][j]等于0号物品的价值
     * 4. 遍历顺序：先遍历物品，或先比遍历重量，都可以；遍历物品更好理解
     * ----------------------一维数组解法分割线----------------------
     * 1. 在一维dp数组中，dp[j]表示:容量为j的背包，所背的物品价值可以最大为dp[j]。
     * 2. 方程式: dp[j]有两个选择，一个是取自己dp[j]，一个是取dp[j - weight[i]] + value[i]，指定是取 最大的，毕竟是求最大价值
     * 2.1      dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
     * 3. 初始化: dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。
     * 4. 顺序: 一维dp遍历的时候，背包是从大到小。倒叙遍历是为了保证物品i只被放入一次!
     */

}
